#|
This file is a part of Qtools Commons
(c) 2018 Michał "phoe" Herda <phoe@disroot.org>
Author: Michał "phoe" Herda <phoe@disroot.org>
|#

(in-package #:qtools-commons)
(in-readtable :qtools)

;;; Code licensed under LICENSE.hue-shift starts here.

(deftype rgb () '(simple-array (unsigned-byte 8) (3)))

(deftype hsv () '(simple-array (single-float 0.0e0 1.0e0) (3)))

(declaim (inline rgb hsv rgb->hsv hsv->rgb rotate-hsv rotate-rgb))
(defun rgb (r g b)
  (declare (optimize speed))
  (make-array '(3) :element-type '(unsigned-byte 8)
                   :initial-contents (list r g b)))

(declaim (inline hsv))
(defun hsv (h s v)
  (declare (optimize speed))
  (make-array '(3) :element-type '(single-float 0.0e0 1.0e0)
                   :initial-contents (list h s v)))

(declaim (inline rgb->hsv))
(defun rgb->hsv (a)
  (declare (optimize speed))
  (declare (type rgb a))
  (let* ((r (* (aref a 0) (coerce 1/255 'single-float)))
         (g (* (aref a 1) (coerce 1/255 'single-float)))
         (b (* (aref a 2) (coerce 1/255 'single-float)))
         (max (max r g b))
         (min (min r g b))
         (v max))
    (if (= max min)
        (make-array '(3) :element-type '(single-float 0.0e0 1.0e0)
                         :initial-contents (list 0.0e0 0.0e0 v))
        (let ((tmp (- max min))
              (s (/ (- max min) max))
              (h 0.0e0))
          (cond ((= r max)
                 (setf h (- (/ (- max b) tmp) (/ (- max g) tmp))))
                ((= g max)
                 (setf h (+ 2.0e0 (- (/ (- max r) tmp) (/ (- max b) tmp)))))
                (t
                 (setf h (+ 4.0e0 (- (/ (- max g) tmp) (/ (- max r) tmp))))))
          (setf h (mod (* h (coerce 1/6 'single-float)) 1))
          (hsv h s v)))))

(declaim (inline hsv->rgb))
(defun hsv->rgb (a)
  (declare (optimize speed))
  (declare (type hsv a))
  (let ((h (aref a 0))
        (s (aref a 1))
        (v (aref a 2)))
    (labels ((unfloat (c)
               (declare (type (single-float 0.0e0 1.0e0) c))
               (coerce (round (* c 255)) 'integer))
             (rgb-from-floats (r g b)
               (declare (type (single-float 0.0e0 1.0e0) r g b))
               (make-array 3 :element-type '(unsigned-byte 8)
                             :initial-contents (list (unfloat r)
                                                     (unfloat g)
                                                     (unfloat b)))))
      (the rgb (if (= s 0.0)
                   (rgb-from-floats v v v)
                   (multiple-value-bind (i f) (truncate (* h 6.0))
                     (declare (type (integer 0 6) i))
                     (let* ((p (* v (- 1.0e0 s)))
                            (q (* v (- 1.0e0 (* s f))))
                            (tv (* v (- 1.0e0 (* s (- 1.0 f))))))
                       (cond ((= i 1) (rgb-from-floats q v p))
                             ((= i 2) (rgb-from-floats p v tv))
                             ((= i 3) (rgb-from-floats p q v))
                             ((= i 4) (rgb-from-floats tv p v))
                             ((= i 5) (rgb-from-floats v p q))
                             (t (rgb-from-floats v tv p))))))))))

(declaim (inline rotate-hsv))
(defun rotate-hsv (a rotation)
  (declare (optimize speed))
  (declare (type hsv a)
           (type (single-float 0.0 (360.0)) rotation))
  (let ((h (aref a 0))
        (s (aref a 1))
        (v (aref a 2))
        (scaled-rotation (* rotation (coerce 1/360 'single-float))))
    (declare (type (single-float 0.0 1.0) scaled-rotation))
    (the hsv (hsv (mod (+ h scaled-rotation) 1.0) s v))))

(declaim (inline rotate-rgb))
(defun rotate-rgb (a rotation)
  (declare (optimize speed))
  (declare (type rgb a)
           (type (single-float 0.0 (360.0)) rotation))
  (let ((hsv (rgb->hsv a)))
    (declare (type hsv hsv))
    (let ((rotated-hsv (rotate-hsv hsv rotation)))
      (declare (type hsv rotated-hsv))
      (let ((rgb (hsv->rgb rotated-hsv)))
        (declare (type rgb rgb))
        (the rgb rgb)))))

;;; Code licensed under LICENSE.hue-shift ends here.

(defun hue-shift (image rotation)
  "Destructively shifts the hue of target image by the provided amount of
degrees. IMAGE must be a ARGB32-format QImage and rotation must be a
single-float between 0.0 (inclusive) and 360.0 (exclusive)."
  (declare (optimize speed))
  (declare (type (single-float 0.0 (360.0)) rotation)
           (type qobject image))
  (assert (qtypep image "QImage") (image)
          "The value of IMAGE is not a QImage: ~A" image)
  (assert (= (the fixnum (qt:enum-value (q+:format image)))
             (the fixnum (q+:qimage.format_argb32))))
  (let ((pointer (q+:bits image))
        (total-size (* (the (unsigned-byte 16) (q+:width image))
                       (the (unsigned-byte 16) (q+:height image)))))
    (dotimes (i total-size)
      (let* ((color (cffi:mem-aref pointer :unsigned-int i))
             (rgb (make-array 3 :element-type '(unsigned-byte 8)
                                :initial-contents
                                (list (ldb (byte 8 0) color)
                                      (ldb (byte 8 8) color)
                                      (ldb (byte 8 16) color))))
             (rgb2 (rotate-rgb rgb rotation))
             (result (+ (aref rgb2 0)
                        (ash (aref rgb2 1) 8)
                        (ash (aref rgb2 2) 16)
                        (ash 255 24))))
        (setf (cffi:mem-aref pointer :unsigned-int i) result)))))
